---
layout: post
title: 关于我
description: 不需奢靡的放纵，也无需寂寞的等待，持之自我，不忘初心
category: blog
---

## 初步的我

陈伟，一个出生在90年的农村娃，刚好也在09年踏上了北来的路。青涩的我，于"千军万马"中争取到自己的船票，第一次远离了家乡，步入大学的殿堂。
大学，每次说道这个词的时候，总有一种别样的感觉。我们曾一起嘻嘻打闹，宣泄彼此的青春；也曾一起静静刷夜复习，只为明天考试的通过;更曾一起开心流泪，为五湖四海的相聚，也为转眼的别离。还记得一起dota，一起逃课睡觉，一起竞赛拼搏，一起考试打怪？那些荒唐的，抑郁的，飞扬的，喜悦的，不思量，自难相望！
后来，我保研了本校的研究生。或许是一个新的开始吧，我适应了阅读长长的英文文献，也适应了独立一个人的科研探索。在这个阶段~~


## 刚离开学校的我

2016年5月，我离开了学校，加入了京东大家庭。放弃通信行业的我，转入了互联网。之所以如此抉择，兴趣使然是一方面，"找不到方向的时候，不妨做一些自己感兴趣的，不要拘束于眼前，失败并不可怕"这句话对我影响也很大。\n
人生就是一个得与失的过程，不可能什么都能抓着。我很幸运，得到的远比失去的多。刚入手工作的压力，使我放弃了大部分业余时间，放弃了学校时的轻松，自己就像块海绵，不停的从同事、网上吸取"水分"。虽然很累，还可能蓬头垢面，但我仍然很享受那些熬得只剩下黑眼圈的日子。
我很感谢我的两个mentor。第一个是我刚入职时mentor，是他带领我进入了服务端开发的大门，在他身上我看到了细心和责任。"coding是一个细致的工作，一个小小的字符错误也可能会引起整个应用的崩溃。每一次提交，你都需要负责的说没问题。"
由于第一个mentor离职，我跟随了第二个mentor。他给我的印象是，高效沟通，懂得调节气氛。每次和产品过需求的时候，能迅速确定重点，梳理完下一步工作。那时因为新项目急于上线，大家压力都很大，可他时不时的一句话总能让大家都乐呵起来，所以我们常常是"苦中作乐"。

## 现在的我

工作一年半了，也差不多算"老人"了。这一年半的时间，我学习使用
- Java 应用
	1) SSH框架原理
	2) jvm虚拟机原理，调优
	3) Java nio
	4) netty 使用
	5) springMVC web
	6) java 集合原理、操作

- 工程化部署
> ##### 1) git、maven项目管理
> ##### 2) jenkins集成
> ##### 3) docker镜像

- 分布式缓存技术
> ##### 1) redis 应用
> ##### 2) memcached 使用

- 分布式接口技术
> ##### 1) dubbo应用
> ##### 2) restFul
> ##### 3) zookeeper

- 分布式消息服务
> ##### 1) ActiveMQ
> ##### 2) Kafka

- 数据库
> mysql

- 大数据
> ##### 1) hdfs基本应用
> ##### 2) hadoop基本应用
> ##### 3) spark scala开发
> ##### 4) mongodb使用

- 机器学习
> ##### 1) 数据预处理，包括特征筛选、缺失值处理等
> ##### 2) 罗辑回归、决策树、随机森林算法

技术学习是一方面，另一方面，我也....



回车 (Carriage Return) 和换行 (Line Feed) 的区别，[这里](http://stackoverflow.com/questions/1761051/difference-between-n-and-r)有一个历史原因可参考：

> 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。

> 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做"回车"，告诉打字机把打印头定位在左边界；另一个叫做"换行"，告诉打字机把纸向下移一行。

发明计算机时，这个概念被沿用下来，但因为条件的限制和设计者的喜好，有了一些分歧：

- Unix 系统里，每行结尾只有"<换行>"，即"\n"
- Windows 系统里面，每行结尾是"<回车><换行>"，即"\r\n"
- 在老的 Mac 系统里，每行结尾是"<回车>"，即"\r"

我们来验证一下，我在 Windows 下用记事本新建一个文本文件，它的二进制编码如下：

    //源文件内容
    hello
    hello2

    //二进制内容
    0000000: 6865 6c6c 6f0d 0a68 656c 6c6f 32         hello..hello2

同样在 Mac 下用 Vim 新建一个：

    //源文件内容
    hello
    hello2

    //二进制内容
    0000000: 6865 6c6c 6f0a 6865 6c6c 6f32 0a         hello.hello2.

`0a`是 LF 的 ASCII 编码, `0d`是 CR 的 ASCII 编码。区别很明显了

- Mac 下的文本文件在 Windows 下打开会成为一行，因为 Windows 只认识`\r\n`，也就是`0d0a`
- Windows 下的文本文件在 Mac 下打开，Vim 中会在每行末尾显示一个 `^M`，(不是两个字符组成的)

## 文件末尾空行

[POSIX](https://zh.wikipedia.org/zh-sg/POSIX)对行的[定义](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206)如下：

  > 3.206 Line

  > A sequence of zero or more non- <newline\> characters plus a terminating <newline\> character.

  > 行是由0个或者多个非 "换行" 符的字符组成，并且以 "换行" 符结尾。

这样做有什么好处呢，举个例子：

    //hello.c
    #include head.h
    print('hello')

    //world.c
    #include tail.h
    print('hello')

如果这两个文件都按 POSIX 规范来写， 在`cat *.c`之后，是没有问题的：

    //cat.c

    #include head.h
    print('hello')
    #include tail.h
    print('hello')

如果缺少最后一行的换行符（如 Windows 文件那样的定义），`cat`之后，就有问题了：

    //error.c

    #include head.h
    print('hello')#include tail.h
    print('hello')

所以，从这点去理解 POSIX 对行的定义，非常合理，对于任意文件的拼接，也各自保持了文件的完整性。

不遵守标准带来的则是：在一些编辑器下面，比如 Sublime，他把`\n`的当做了行之间的分隔符，于是文件最后一行的`\n`就看上去成了一个新的空行，这就是错误解读标准造成的，拼接文件时也会产生不必要的麻烦，比如上例。

## \ No new line at end of file

基于上面的原因，再去看 git diff 的`\ No new line at end of file`信息，就很好解释了。

各编辑器对于换行符的理解偏差，导致的文件确实发生了变化，多了或少了最后的`0a`，那么对于 diff 程序来说，这当然是不可忽略的，但因为`0a`是不可见字符，并且是长久以来的历史原因，所以 diff 程序有个专门的标记来说明这个变化，就是：

`\ No new line at end of file`

各编辑器也有相应的办法去解决这个问题，比如 Sublime，在`Default/Preferences.sublime-settings`中设置：

    // Set to true to ensure the last line of the file ends in a newline
    // character when saving
    "ensure_newline_at_eof_on_save": true,

所以，请遵守规范。

[BeiYuu]:    http://beiyuu.com  "BeiYuu"
