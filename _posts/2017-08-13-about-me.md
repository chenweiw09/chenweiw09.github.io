---
layout: post
title: 关于我
description: 不需奢靡的放纵，也无需寂寞的等待，持之自我，不忘初心
category: blog
---

## 初步的我

陈伟，一个出生在90年的四川农村娃。09年的时候，经历高考的"千军万马过独桥"，第一次远离了家乡，踏上了北去的火车，步入大学（北邮）的殿堂。当初的我，青涩、容易害羞。

大学，真的是一个具有魔力的时间段，教会了我"玩耍"，教会了我青春萌动，也教会了我成熟思考。我们曾一起逃课睡觉，只为谁起的更晚；也曾一起刷夜复习，为明天考试的通过；曾一起嘻嘻打闹，宣泄彼此的青春；亦曾静坐沉思，考量未来的何去何从。"恰同学少年，风华正茂。书生意气，挥斥方遒"。毕业时，我们一起开心，一起流泪，为五湖四海的相聚，也为转眼的别离。那时的我，青春、热血。

后来，我保研了本校的研究生。或许是一个新的开始吧，心开始静下来~ 适应了阅读长长的英文文献，适应了一个人的科研探索，也适应了团队的分工合作。随后，coding也成了我生活的一部分。所以，研究生阶段一边是责任心所在，一边是科研的繁琐和孤独，结果是不在沉默中死亡，就在沉默中疯狂成长。毕业时的我，沉着，带着对未来的思考。


## 刚离开学校的我

2016年4月，我离开了学校，加入了京东大家庭。放弃通信行业的我，转入了互联网。之所以如此抉择，兴趣使然是一方面，"找不到方向的时候，不妨做一些自己感兴趣的，不要拘束于眼前，失败并不可怕"这句话对我影响也很大。

很多时候，人生都选择得与失，不可能什么都能抓着。我很幸运，得到的远比失去的多。刚工作时，项目的压力使我放弃了大部分业余时间，放弃了学校时的轻松，自己就像块海绵，不停的从同事、网上吸取"水分"。虽然很累，还可能蓬头垢面，但我仍然很享受那些熬得只剩下黑眼圈的日子。

在这里，我很感谢我的两个mentor。第一个是我刚入职时的mentor，他带领我进入了服务端开发的大门。他经常说，"coding是一个细致的工作，一个小小的字符错误也可能会引起整个应用的崩溃。所以每一次提交代码，你都需要负责的说没问题"。在他身上我看到了细心和责任。

第二个mentor带给我的则是高效沟通，懂得"苦中作乐"。那时因为新项目急于上线，大家压力都很大，可他时不时来一句话调节气氛，总能让大家都乐呵起来，所以很累，但状态都还OK。

## 现在的我

工作一年半了，也差不多算"老人"了。这一年半的时间，我学习使用
- Java 应用
	1) SSH框架原理
	2) jvm虚拟机原理，调优
	3) Java nio
	4) netty 使用
	5) springMVC web
	6) java 集合原理、操作

- 工程化部署
	1) git、maven项目管理
	2) jenkins集成
	3) docker镜像

- 分布式缓存技术
	1) redis 应用
	2) memcached 使用

- 分布式接口技术
	1) dubbo应用
	2) restFul
	3) zookeeper

- 分布式消息服务
	1) ActiveMQ
	2) Kafka

- 数据库
> mysql

- 大数据
	1) hdfs基本应用
	2) hadoop基本应用
	3) spark scala开发
	4) mongodb使用

- 机器学习
	1) 数据预处理，包括特征筛选、缺失值处理等
	2) 罗辑回归、决策树、随机森林算法

技术学习是一方面，另一方面，我也....



回车 (Carriage Return) 和换行 (Line Feed) 的区别，[这里](http://stackoverflow.com/questions/1761051/difference-between-n-and-r)有一个历史原因可参考：

> 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。

> 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做"回车"，告诉打字机把打印头定位在左边界；另一个叫做"换行"，告诉打字机把纸向下移一行。

发明计算机时，这个概念被沿用下来，但因为条件的限制和设计者的喜好，有了一些分歧：

- Unix 系统里，每行结尾只有"<换行>"，即"\n"
- Windows 系统里面，每行结尾是"<回车><换行>"，即"\r\n"
- 在老的 Mac 系统里，每行结尾是"<回车>"，即"\r"

我们来验证一下，我在 Windows 下用记事本新建一个文本文件，它的二进制编码如下：

    //源文件内容
    hello
    hello2

    //二进制内容
    0000000: 6865 6c6c 6f0d 0a68 656c 6c6f 32         hello..hello2

同样在 Mac 下用 Vim 新建一个：

    //源文件内容
    hello
    hello2

    //二进制内容
    0000000: 6865 6c6c 6f0a 6865 6c6c 6f32 0a         hello.hello2.

`0a`是 LF 的 ASCII 编码, `0d`是 CR 的 ASCII 编码。区别很明显了

- Mac 下的文本文件在 Windows 下打开会成为一行，因为 Windows 只认识`\r\n`，也就是`0d0a`
- Windows 下的文本文件在 Mac 下打开，Vim 中会在每行末尾显示一个 `^M`，(不是两个字符组成的)

## 文件末尾空行

[POSIX](https://zh.wikipedia.org/zh-sg/POSIX)对行的[定义](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206)如下：

  > 3.206 Line

  > A sequence of zero or more non- <newline\> characters plus a terminating <newline\> character.

  > 行是由0个或者多个非 "换行" 符的字符组成，并且以 "换行" 符结尾。

这样做有什么好处呢，举个例子：

    //hello.c
    #include head.h
    print('hello')

    //world.c
    #include tail.h
    print('hello')

如果这两个文件都按 POSIX 规范来写， 在`cat *.c`之后，是没有问题的：

    //cat.c

    #include head.h
    print('hello')
    #include tail.h
    print('hello')

如果缺少最后一行的换行符（如 Windows 文件那样的定义），`cat`之后，就有问题了：

    //error.c

    #include head.h
    print('hello')#include tail.h
    print('hello')

所以，从这点去理解 POSIX 对行的定义，非常合理，对于任意文件的拼接，也各自保持了文件的完整性。

不遵守标准带来的则是：在一些编辑器下面，比如 Sublime，他把`\n`的当做了行之间的分隔符，于是文件最后一行的`\n`就看上去成了一个新的空行，这就是错误解读标准造成的，拼接文件时也会产生不必要的麻烦，比如上例。

## \ No new line at end of file

基于上面的原因，再去看 git diff 的`\ No new line at end of file`信息，就很好解释了。

各编辑器对于换行符的理解偏差，导致的文件确实发生了变化，多了或少了最后的`0a`，那么对于 diff 程序来说，这当然是不可忽略的，但因为`0a`是不可见字符，并且是长久以来的历史原因，所以 diff 程序有个专门的标记来说明这个变化，就是：

`\ No new line at end of file`

各编辑器也有相应的办法去解决这个问题，比如 Sublime，在`Default/Preferences.sublime-settings`中设置：

    // Set to true to ensure the last line of the file ends in a newline
    // character when saving
    "ensure_newline_at_eof_on_save": true,

所以，请遵守规范。

[BeiYuu]:    http://beiyuu.com  "BeiYuu"
